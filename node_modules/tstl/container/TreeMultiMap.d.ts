/** @module std */
import { MultiMap } from "../base/container/MultiMap";
import { ITreeMap } from "../base/container/ITreeMap";
import { MapIterator, MapReverseIterator } from "../base/iterator/MapIterator";
import { IForwardIterator } from "../iterator/IForwardIterator";
import { IPair } from "../utility/IPair";
import { Pair } from "../utility/Pair";
/**
 * Multiple-key Map based on Tree.
 *
 * @author Jeongho Nam <http://samchon.org>
 */
export declare class TreeMultiMap<Key, T> extends MultiMap<Key, T, TreeMultiMap<Key, T>> implements ITreeMap<Key, T, false, TreeMultiMap<Key, T>> {
    /**
     * @hidden
     */
    private tree_;
    /**
     * Default Constructor.
     *
     * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Note that, because *equality* is predicated by `!comp(x, y) && !comp(y, x)`, the function must not cover the *equality* like `<=` or `>=`. It must exclude the *equality* like `<` or `>`. Default is {@link less}.
     */
    constructor(comp?: (x: Key, y: Key) => boolean);
    /**
     * Initializer Constructor.
     *
     * @param items Items to assign.
     * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Note that, because *equality* is predicated by `!comp(x, y) && !comp(y, x)`, the function must not cover the *equality* like `<=` or `>=`. It must exclude the *equality* like `<` or `>`. Default is {@link less}.
     */
    constructor(items: IPair<Key, T>[], comp?: (x: Key, y: Key) => boolean);
    /**
     * Copy Constructor.
     *
     * @param obj Object to copy.
     */
    constructor(obj: TreeMultiMap<Key, T>);
    /**
     * Range Constructor.
     *
     * @param first Input iterator of the first position.
     * @param last Input iterator of the last position.
     * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Note that, because *equality* is predicated by `!comp(x, y) && !comp(y, x)`, the function must not cover the *equality* like `<=` or `>=`. It must exclude the *equality* like `<` or `>`. Default is {@link less}.
     */
    constructor(first: Readonly<IForwardIterator<IPair<Key, T>>>, last: Readonly<IForwardIterator<IPair<Key, T>>>, comp?: (x: Key, y: Key) => boolean);
    /**
     * @inheritDoc
     */
    clear(): void;
    /**
     * @inheritDoc
     */
    swap(obj: TreeMultiMap<Key, T>): void;
    /**
     * @inheritDoc
     */
    find(key: Key): TreeMultiMap.Iterator<Key, T>;
    /**
     * @inheritDoc
     */
    count(key: Key): number;
    /**
     * @inheritDoc
     */
    key_comp(): (x: Key, y: Key) => boolean;
    /**
     * @inheritDoc
     */
    value_comp(): (x: IPair<Key, T>, y: IPair<Key, T>) => boolean;
    /**
     * @inheritDoc
     */
    lower_bound(key: Key): TreeMultiMap.Iterator<Key, T>;
    /**
     * @inheritDoc
     */
    upper_bound(key: Key): TreeMultiMap.Iterator<Key, T>;
    /**
     * @inheritDoc
     */
    equal_range(key: Key): Pair<TreeMultiMap.Iterator<Key, T>, TreeMultiMap.Iterator<Key, T>>;
    /**
     * @hidden
     */
    protected _Key_eq(x: Key, y: Key): boolean;
    /**
     * @inheritDoc
     */
    emplace(key: Key, val: T): TreeMultiMap.Iterator<Key, T>;
    /**
     * @inheritDoc
     */
    emplace_hint(hint: TreeMultiMap.Iterator<Key, T>, key: Key, val: T): TreeMultiMap.Iterator<Key, T>;
    /**
     * @hidden
     */
    protected _Insert_by_range<InputIterator extends Readonly<IForwardIterator<IPair<Key, T>, InputIterator>>>(first: InputIterator, last: InputIterator): void;
    /**
     * @hidden
     */
    protected _Handle_insert(first: TreeMultiMap.Iterator<Key, T>, last: TreeMultiMap.Iterator<Key, T>): void;
    /**
     * @hidden
     */
    protected _Handle_erase(first: TreeMultiMap.Iterator<Key, T>, last: TreeMultiMap.Iterator<Key, T>): void;
}
export declare namespace TreeMultiMap {
    type Iterator<Key, T> = MapIterator<Key, T, false, TreeMultiMap<Key, T>>;
    type ReverseIterator<Key, T> = MapReverseIterator<Key, T, false, TreeMultiMap<Key, T>>;
    const Iterator: typeof MapIterator;
    const ReverseIterator: typeof MapReverseIterator;
    type iterator<Key, T> = Iterator<Key, T>;
    type reverse_iterator<Key, T> = ReverseIterator<Key, T>;
    const iterator: typeof MapIterator;
    const reverse_iterator: typeof MapReverseIterator;
}
export import multimap = TreeMultiMap;
//# sourceMappingURL=TreeMultiMap.d.ts.map