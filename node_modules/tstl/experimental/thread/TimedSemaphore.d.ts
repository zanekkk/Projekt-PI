/** @module std.experimental */
import { _ISemaphore } from "../../base/thread/_ISemaphore";
/**
 * Timed semaphore.
 *
 * @author Jeongho Nam <http://samchon.org>
 */
export declare class TimedSemaphore implements _ISemaphore {
    /**
     * @hidden
     */
    private hold_count_;
    /**
     * @hidden
     */
    private locked_count_;
    /**
     * @hidden
     */
    private size_;
    /**
     * @hidden
     */
    private resolvers_;
    /**
     * Construct from section size.
     *
     * @param size Number of maximum sections lockable.
     */
    constructor(size: number);
    /**
     * @inheritDoc
     */
    size(): number;
    /**
     * @hidden
     */
    private _Compute_excess_count;
    /**
     * @hidden
     */
    private _Compute_resolve_count;
    /**
     * @inheritDoc
     */
    lock(count?: number): Promise<void>;
    /**
     * @inheritDoc
     */
    try_lock(count?: number): Promise<boolean>;
    /**
     * @inheritDoc
     */
    unlock(count?: number): Promise<void>;
    /**
     * @hidden
     */
    private _Unlock;
    /**
     * Try lock sections until timeout.
     *
     * @param ms The maximum miliseconds for waiting.
     * @param count Count to lock.
     * @return Whether succeded to lock or not.
     */
    try_lock_for(ms: number, count?: number): Promise<boolean>;
    /**
     * Try lock sections until time expiration.
     *
     * @param at The maximum time point to wait.
     * @param count Count to lock.
     * @return Whether succeded to lock or not.
     */
    try_lock_until(at: Date, count?: number): Promise<boolean>;
}
export declare type timed_semaphore = TimedSemaphore;
export declare const timed_semaphore: typeof TimedSemaphore;
//# sourceMappingURL=TimedSemaphore.d.ts.map